| Лабораторная работа №3    | 24Б10                   | Архитектура компьютера |
| ------------------------- | ----------------------- | ---------------------- |
| Эмулятор RISC-V           | Согоян Вазген Айкович   | 2025                   |

## Инструментарий

Язык C++, стандарт C++23

## Что реализовано

> Пишем что было выполнено. Если что-то по ТЗ не работает, то лучше указать это здесь.

# Описание

## Полученные параметры системы

| Параметр         | Значение (с единицами измерения) |
| ---------------- | -------------------------------- |
| MEMORY_SIZE      | 256 КБ (262 144 байт)            |
| ADDRESS_LEN      | 18 бит                           |
| CACHE_TAG_LEN    | 8 бит                            |
| CACHE_INDEX_LEN  | 5 бит                            |
| CACHE_OFFSET_LEN | 5 бит                            |
| CACHE_SIZE       | 4 КБ (4096 байт)                 |
| CACHE_LINE_SIZE  | 32 байта                         |
| CACHE_LINE_COUNT | 128 линий                        |
| CACHE_SET_COUNT  | 32 набора (set)                  |
| CACHE_WAY        | 4‑х канальный (4 way)            |

**1. Размер адресного пространства**

MEMORY_SIZE = 256 * 1024 = 262 144 байт = 2¹⁸ байт, следовательно:

ADDRESS_LEN = log2(MEMORY_SIZE) = 18 бит.

**2. Разбиение адреса**

Адрес в кэше состоит из:

- CACHE_TAG_LEN = 8 бит (тег) 
- CACHE_INDEX_LEN = 5 бит (индекс набора) 
- CACHE_OFFSET_LEN = ? (смещение в строке)

CACHE_OFFSET_LEN = ADDRESS_LEN − CACHE_TAG_LEN − CACHE_INDEX_LEN = 18 − 8 − 5 = 5 бит.

**3. Размер строки кэша**

Размер строки определяется количеством бит смещения:

CACHE_LINE_SIZE = 2^CACHE_OFFSET_LEN = 2⁵ = 32 байта.

**4. Организация кэша**

* Количество наборов (set):

CACHE_SET_COUNT = 2^CACHE_INDEX_LEN = 2⁵ = 32.

* Ассоциативность кэша:

CACHE_WAY = 4.

* Общее количество строк кэша:

CACHE_LINE_COUNT = CACHE_SET_COUNT * CACHE_WAY = 32 * 4 = 128 строк.

**5. Общий размер кэша**

CACHE_SIZE = CACHE_LINE_COUNT * CACHE_LINE_SIZE = 128 * 32 = 4096 байт = 4 КБ.

## Cache

**CacheStats**

```cpp
struct CacheStats {
    uint64_t instr_access = 0;
    uint64_t instr_hit = 0;
    uint64_t data_access = 0;
    uint64_t data_hit = 0;
};
```

**Line**

Приватный в CacheAbstract, о котором ниже

```cpp
struct Line {
    uint8_t data[CACHE_LINE_SIZE]; // данные строки
    bool valid = false; // бит валидности
    bool dirty = false; // различается ли от данных в оперативке
    uint32_t tag = 0; // тег адреса
};
```

**CacheAbstract**

Я создал абстрактный класс CacheAbstract, от которого будут наследоваться конкретные реализации кешей. В нем реализована общая логика в методах, но оставлены чистые виртуальные методы, которые необходимо перегрузить для конкретного потомка (если это правильное слово в ооп).

Общее реализовано:

* конструктор, просто принимающий оперативку и инициализирующий линии кеша в 0
* protected метод fetch_line
* через fetch_line логика чтения и записи данных (8,16,32 бита, единой операцией)
* сбор статистики обращений и попаданий
* виртульные методы для перегрузки тоже protected

Вот линии кеша:

```cpp
Line cache_[CACHE_SET_COUNT][CACHE_WAY];
```

Алгоритм чтения:

1. Увеличивается счётчик обращений (instruction или data)
2. Выполняется поиск строки в соответствующем наборе:
   * если строка найдена и валидна → hit
   * иначе → miss
3. При промахе строка загружается из RAM
4. Возвращается значение из строки по смещению

Запись реализована по политике write-back + write-allocate:

* данные записываются только в кэш
* строка помечается как dirty
* в RAM данные попадают либо при вытеснении, либо при вызове flush() (ниже)

Основная логика загрузки и вытеснение строк реализована в методе:

```cpp
Line& fetch_line(uint32_t addr, AccessType type)
```

Алгоритм:

1. Поиск строки с совпадающим тегом в наборе
2. Если строка найдена → hit:
   * обновляется статистика
   * вызывается виртуальный on_hit
3. Если есть свободная (invalid) строка:
   * строка загружается из RAM
   * вызывается виртуальный on_fill
4. Если набор полностью занят:
   * выбирается строка-жертва (виртуальный choose_victim)
   * при необходимости dirty-строка записывается обратно в RAM
   * загружается новая строка

Метод flush() выигружает все dirty строки в оперативку. Используется для корректного завершения работы и синхронизации памяти.

**CacheLRU**

Для каждого набора хранится массив last_used[set][way]:
* Значение 0 соответствует самой недавно использованной строке.
* При каждом попадании и заполнении обновляется порядок использования.
* Вытесняется строка с максимальным значением (CACHE_WAY - 1).

При попадании (on_hit):
* выбранная строка помечается как самая свежая (0)
* все строки, использованные раньше неё, стареют

При заполнении (on_fill):
* новая строка становится самой свежей
* остальные строки стареют

При вытеснении (choose_victim):
* выбирается строка с максимальным last_used

**CacheBpLRU**

Для каждой строки хранится один бит used:
* 1 — строка использовалась недавно, 0 — кандидат на вытеснение

При попадании и заполнении (on_hit / on_fill):
* бит соответствующей строки устанавливается в 1,
* если все биты в наборе стали 1, они сбрасываются, кроме текущей строки.

При вытеснении (choose_victim):
* выбирается первая строка с used == false,
* если таких нет — все биты сбрасываются и выбирается первая строка.

---

> Раздел, в котором вы описываете свою реализацию:
>
> Cache:
> - какие классы/функции созданы для представления кеша, как реализованы политики вытеснения и конфигурация в целом, как он работает.
>
> ISA:
> - как выполнено чтение и парсинг входного файла, какие структуры в коде были реализованы для хранения/представления команд.
>
> Моделирование задачи (task.bin):
> - результат работы написанной программы (то, что выводится в стандартный поток вывода / файл при разных аргументах командной строки).
>
> ... прочее, что считаете полезным описать

### Примечания по оформлению (удалить из итоговой версии отчёта)

1. Не нужно вставлять своё описание как quote (цитату).
2. Разбивайте ваш текст на логические разделы и отделяйте их заголовками.
3. Если хочется вставить фрагменты кода, то делаете это блоком кода. Если же ссылаетесь на код, то делайте это через permalink на файлы в репозитории. Не нужно вставлять большую копипасту кода из своего исходника.
4. Можно пользоваться всеми возможностями [Github Markdown](https://docs.github.com/ru/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/quickstart-for-writing-on-github). Главное, чтобы корректно рендерилось на GitHub.
5. Никаких фоток в отчёте, ровно как и скринов полного экрана!
6. Если вам нужны изображения, то создайте в репозитории папку, в котором все эти изображения будут лежать и [ссылайтесь на них](https://docs.github.com/ru/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax#images).
