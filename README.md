| Лабораторная работа №3    | 24Б10                   | Архитектура компьютера |
| ------------------------- | ----------------------- | ---------------------- |
| Эмулятор RISC-V           | Согоян Вазген Айкович   | 2025 декабрь           |


## Файл с заданием

[Тут](lab3_riscv_emulator.pdf), файл lab3_riscv_emulator.pdf!

## Инструментарий

Язык C++, стандарт C++23

## Что реализовано

В рамках лабораторной работы реализован эмулятор процессора RISC-V RV32 с поддержкой двух видов кэшей: LRU и bpLRU.

* Реализован RAM с побайтовым чтением и записью, проверкой выхода за границы памяти
* Создан абстрактный кэш CacheAbstract с write-back + write-allocate политикой и сбором статистики
* Реализованы CacheLRU и CacheBpLRU с соответствующими алгоритмами вытеснения
* Реализован Processor, который:
  * хранит 32 регистра и program counter
  * выполняет инструкции RV32I, RV32M
  * для работы с памятью обращается к кешу
* В main.cpp:
  * чтение входного файла с регистрами и памятью
  * загрузка RAM и кэша
  * исполнение программы через два процессора с разными кэшами
  * вывод статистики по cache-hit для LRU и bpLRU
  * при необходимости запись выходного файла с регистрами и блоком памяти

# Описание

## Полученные параметры системы

| Параметр         | Значение (с единицами измерения) |
| ---------------- | -------------------------------- |
| MEMORY_SIZE      | 256 КБ (262 144 байт)            |
| ADDRESS_LEN      | 18 бит                           |
| CACHE_TAG_LEN    | 8 бит                            |
| CACHE_INDEX_LEN  | 5 бит                            |
| CACHE_OFFSET_LEN | 5 бит                            |
| CACHE_SIZE       | 4 КБ (4096 байт)                 |
| CACHE_LINE_SIZE  | 32 байта                         |
| CACHE_LINE_COUNT | 128 линий                        |
| CACHE_SET_COUNT  | 32 набора (set)                  |
| CACHE_WAY        | 4‑х канальный (4 way)            |

**1. Размер адресного пространства**

MEMORY_SIZE = 256 * 1024 = 262 144 байт = 2¹⁸ байт, следовательно:

ADDRESS_LEN = log2(MEMORY_SIZE) = 18 бит.

**2. Разбиение адреса**

Адрес в кэше состоит из:

- CACHE_TAG_LEN = 8 бит (тег) 
- CACHE_INDEX_LEN = 5 бит (индекс набора) 
- CACHE_OFFSET_LEN = ? (смещение в строке)

CACHE_OFFSET_LEN = ADDRESS_LEN − CACHE_TAG_LEN − CACHE_INDEX_LEN = 18 − 8 − 5 = 5 бит.

**3. Размер строки кэша**

Размер строки определяется количеством бит смещения:

CACHE_LINE_SIZE = 2^CACHE_OFFSET_LEN = 2⁵ = 32 байта.

**4. Организация кэша**

* Количество наборов (set):

CACHE_SET_COUNT = 2^CACHE_INDEX_LEN = 2⁵ = 32.

* Ассоциативность кэша:

CACHE_WAY = 4.

* Общее количество строк кэша:

CACHE_LINE_COUNT = CACHE_SET_COUNT * CACHE_WAY = 32 * 4 = 128 строк.

**5. Общий размер кэша**

CACHE_SIZE = CACHE_LINE_COUNT * CACHE_LINE_SIZE = 128 * 32 = 4096 байт = 4 КБ.

## RAM

Память хранится как динамически (оператором new) выделенный массив байт:

```cpp
uint8_t* data_;
```

Размер памяти задаётся при создании объекта и хранится в поле size_. Каждый элемент массива соответствует одному байту памяти.

Деструктор освобождает выделенную память.

Читаем и пишем побайтово:
* read8(address)
* write8(address, value)

Бросается std::out_of_range, если адрес, по которому хотим обратиться, вне адресного пространства.

## Cache

**CacheStats**

```cpp
struct CacheStats {
    uint64_t instr_access = 0;
    uint64_t instr_hit = 0;
    uint64_t data_access = 0;
    uint64_t data_hit = 0;
};
```

**Line**

Приватный в CacheAbstract, о котором ниже

```cpp
struct Line {
    uint8_t data[CACHE_LINE_SIZE]; // данные строки
    bool valid = false; // бит валидности
    bool dirty = false; // различается ли от данных в оперативке
    uint32_t tag = 0; // тег адреса
};
```

**CacheAbstract**

Я создал абстрактный класс CacheAbstract, от которого будут наследоваться конкретные реализации кешей. В нем реализована общая логика в методах, но оставлены чистые виртуальные методы, которые необходимо перегрузить для конкретного потомка (если это правильное слово в ооп).

Общее реализовано:

* конструктор, просто принимающий оперативку и инициализирующий линии кеша в 0
* protected метод fetch_line
* через fetch_line логика чтения и записи данных (8,16,32 бита, единой операцией)
* сбор статистики обращений и попаданий
* виртульные методы для перегрузки тоже protected

Вот линии кеша:

```cpp
Line cache_[CACHE_SET_COUNT][CACHE_WAY];
```

Алгоритм чтения:

1. Увеличивается счётчик обращений (instruction или data)
2. Выполняется поиск строки в соответствующем наборе:
   * если строка найдена и валидна → hit
   * иначе → miss
3. При промахе строка загружается из RAM
4. Возвращается значение из строки по смещению

Запись реализована по политике write-back + write-allocate:

* данные записываются только в кэш
* строка помечается как dirty
* в RAM данные попадают либо при вытеснении, либо при вызове flush() (ниже)

Основная логика загрузки и вытеснение строк реализована в методе:

```cpp
Line& fetch_line(uint32_t addr, AccessType type)
```

Алгоритм:

1. Поиск строки с совпадающим тегом в наборе
2. Если строка найдена → hit:
   * обновляется статистика
   * вызывается виртуальный on_hit
3. Если есть свободная (invalid) строка:
   * строка загружается из RAM
   * вызывается виртуальный on_fill
4. Если набор полностью занят:
   * выбирается строка-жертва (виртуальный choose_victim)
   * при необходимости dirty-строка записывается обратно в RAM
   * загружается новая строка

Метод flush() выигружает все dirty строки в оперативку. Используется для корректного завершения работы и синхронизации памяти.

**CacheLRU**

Для каждого набора хранится массив last_used[set][way]:
* Значение 0 соответствует самой недавно использованной строке.
* При каждом попадании и заполнении обновляется порядок использования.
* Вытесняется строка с максимальным значением (CACHE_WAY - 1).

При попадании (on_hit):
* выбранная строка помечается как самая свежая (0)
* все строки, использованные раньше неё, стареют

При заполнении (on_fill):
* новая строка становится самой свежей
* остальные строки стареют

При вытеснении (choose_victim):
* выбирается строка с максимальным last_used

**CacheBpLRU**

Для каждой строки хранится один бит used:
* 1 — строка использовалась недавно, 0 — кандидат на вытеснение

При попадании и заполнении (on_hit / on_fill):
* бит соответствующей строки устанавливается в 1,
* если все биты в наборе стали 1, они сбрасываются, кроме текущей строки.

При вытеснении (choose_victim):
* выбирается первая строка с used == false,
* если таких нет — все биты сбрасываются и выбирается первая строка.

## Processor

Процессор хранит:

* regs_ — массив из 32 регистров
* pc_ — program counter
* start_ra_ — значения регистра ra на старте программы (для конца программы)
* cache_ — ссылка на кэш (CacheAbstract)

Регистр 0 аппаратно зафиксирован в нуле после каждой записи.

Храним кеш и напрямую обращаемся только к нему. Промахи и всю всю логику реализует он, к оперативке обращается он.

**Цикл выполнения**

Метод run() реализует основной цикл:

1. Читаем очередную инструкцию
2. Декодирование инструкции (parse)
3. Проверка корректности opcode
4. Выбор обработчика по opcode (get_function)
5. Выполнение инструкции

После завершения работы цикла вызывается cache_.flush() для записи dirty линий в оперативку.

**Command, декодирование инструкций**

```cpp
struct Command {
    uint32_t raw = 0;      // исходное 32-битное значение инструкции
    uint8_t opcode = 0;    // код операции (7 бит)
    uint8_t rd = 0;        // номер регистра назначения (5 бит)
    uint8_t funct3 = 0;    // поле funct3 (3 бит)
    uint8_t rs1 = 0;       // номер первого регистра-операнда (5 бит)
    uint8_t rs2 = 0;       // номер второго регистра-операнда (5 бит)
    uint8_t funct7 = 0;    // поле funct7 (7 бит)
    uint16_t funct12 = 0;  // поле funct12 (12 бит, для системных инструкций)
    int32_t imm = 0;       // знаково расширенное immediate (32 бит)
};
```

Метод parse(uint32_t raw_instr) корректно вычленяет все данные, записывая в структуру.

**Выполнение инструкций**

Каждый класс инструкций вынесен в отдельный метод:

* exec_r_type — арифметика и умножение/деление (RV32M)
* exec_load / exec_store — загрузка и запись данных
* exec_imm_arith — арифметика с immediate
* exec_branch — условные переходы
* exec_jal, exec_jalr — безусловные переходы
* exec_lui, exec_auipc — загрузка констант
* exec_system — ECALL / EBREAK (остановка)

Там в основном "switch case"-ами делаются соотв действия.

## Main

В main.cpp происходит:

* чтение исходных регистров и памяти из бинарного файла
* загрузка данных в RAM
* выполнение инструкций через два разных процессора, у которых разные виды кеша
* вывод статистики по двум кешам
* при необходимости — запись итоговых регистров и фрагмента памяти в бинарный файл.

**Чтение входных данных**

Файл входных данных читается функцией read_input_file четко по требованиям лабораторной.

Функция load_memory(RAM&, const std::map<…>&) последовательно записывает каждый фрагмент в RAM через метод write8.

**Исполнение комманд**

Для каждого типа кэша:

1. Создаётся объект RAM фиксированного размера (MEMORY_SIZE)
2. Загружается память из InputData
3. Создаётся кэш (CacheLRU или CacheBpLRU) поверх RAM
4. Создаётся процессор Processor, который получает кэш и копию регистров.
5. Вызывается cpu.run() — процессор выполняет инструкции до конца программы:

**Вывод статистики**

Функция print_stats выводит данные четко по формату, данному в требованиях лабораторной.

**Выходные данные**

Если передан ключ -o, вызывается write_output_file:

1. Проверка диапазона адресов и размера памяти для записи
2. Запись итоговых 32 регистров процессора
3. Запись адреса и размера блока памяти
4. Сохранение байтов памяти по указанному диапазону
5. Выходной файл структурирован аналогично входному для возможного последующего анализа

## Task bin

Рассуждение дублируется так же в task.asm

**Рассуждение:**

Инструкций всего 19. Промах только для первой инструкции, так как кэш пуст. 

Следующие 5 команд 1ого фрагмента памяти закэшируются, так
как это все и еще чуть больше помещается в одну кеш линию.

Фрагмент памяти 2 будет закеширован еще до того, как мы начнем исполнять
команды оттуда, так как в команде номер 2 ("lw x8, 0(x4)") мы обращаемся
по этому адресу (как к данным) и кэшируем в том числе все инструкции
фрагмента 2.

Аналогично с инструкциями фрагмента 3, они кешируются в команде номер 3
и из кеша не вытесняются.

Обращений к данным ровно 16. Из них 6 промазывают.

Все обращения фрагмента 1 - промазы. И они все имеют один тег => происходит
одно вытеснение из кэша. Больше вытеснений нет, так как есть лишь еще один
промаз по данным: загрузка из 0(x9), но у него другой тег.

Остальные 10 обращений к данным являются обращениями к уже закэшированному
адресу 0(x4).

В конце фрагментов памяти 1 и 2 происходят переходы на следующие
фрагменты, 2 и 3 соответственно.

Всего получаю 18/19 и 10/16 попаданий по инструкциям и по данным соответственно.
Это от меня и требовалось.

**Значения регистров:**

pc = x0 = 0x0
x1 = 0x2000
x2 = 0xf000
x3 = 0x400
x4 = 0x800
x5 = 0x900
x6 = 0x1000
x7 = 0x1400
x8 = 0x10000
x9 = 0x11000
x10..31 = 0

**Код:**

```assembly
# 1 фрагмент памяти, адрес 0x0, размер 6 * 4 байта = 24 байта
lw x8, 0(x3)
lw x8, 0(x4)
lw x8, 0(x5)
lw x8, 0(x6)
lw x8, 0(x7)
jalr x0, 0(x4)

# 2 фрагмент памяти, адрес 0x800, размер 7 * 4 байта = 28 байт
lw x8, 0(x9)
lw x8, 0(x4)
lw x8, 0(x4)
lw x8, 0(x4)
lw x8, 0(x4)
lw x8, 0(x4)
jalr x0, 0(x5)

# 3 фрагмент памяти, адрес 0x900, размер 6 * 4 байта = 24 байта
lw x8, 0(x4)
lw x8, 0(x4)
lw x8, 0(x4)
lw x8, 0(x4)
lw x8, 0(x4)
ebreak
```

# СПАСИБО!
